{"ast":null,"code":"'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis,undefinedVars}\n   */\n\n  Zone.__load_patch('Error', function (global, Zone, api) {\n    /*\n     * This code patches Error so that:\n     *   - It ignores un-needed stack frames.\n     *   - It Shows the associated Zone for reach frame.\n     */\n    var zoneJsInternalStackFramesSymbol = api.symbol('zoneJsInternalStackFrames');\n    var NativeError = global[api.symbol('Error')] = global['Error']; // Store the frames which should be removed from the stack frames\n\n    var zoneJsInternalStackFrames = {}; // We must find the frame where Error was created, otherwise we assume we don't understand stack\n\n    var zoneAwareFrame1;\n    var zoneAwareFrame2;\n    var zoneAwareFrame1WithoutNew;\n    var zoneAwareFrame2WithoutNew;\n    var zoneAwareFrame3WithoutNew;\n    global['Error'] = ZoneAwareError;\n    var stackRewrite = 'stackRewrite';\n    var zoneJsInternalStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] || global['__Zone_Error_ZoneJsInternalStackFrames_policy'] || 'default';\n\n    function buildZoneFrameNames(zoneFrame) {\n      var zoneFrameName = {\n        zoneName: zoneFrame.zone.name\n      };\n      var result = zoneFrameName;\n\n      while (zoneFrame.parent) {\n        zoneFrame = zoneFrame.parent;\n        var parentZoneFrameName = {\n          zoneName: zoneFrame.zone.name\n        };\n        zoneFrameName.parent = parentZoneFrameName;\n        zoneFrameName = parentZoneFrameName;\n      }\n\n      return result;\n    }\n\n    function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame) {\n      if (isZoneFrame === void 0) {\n        isZoneFrame = true;\n      }\n\n      var frames = originalStack.split('\\n');\n      var i = 0; // Find the first frame\n\n      while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 || frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew || frames[i] === zoneAwareFrame3WithoutNew) && i < frames.length) {\n        i++;\n      }\n\n      for (; i < frames.length && zoneFrame; i++) {\n        var frame = frames[i];\n\n        if (frame.trim()) {\n          switch (zoneJsInternalStackFrames[frame]) {\n            case 0\n            /* zoneJsInternal */\n            :\n              frames.splice(i, 1);\n              i--;\n              break;\n\n            case 1\n            /* transition */\n            :\n              if (zoneFrame.parent) {\n                // This is the special frame where zone changed. Print and process it accordingly\n                zoneFrame = zoneFrame.parent;\n              } else {\n                zoneFrame = null;\n              }\n\n              frames.splice(i, 1);\n              i--;\n              break;\n\n            default:\n              frames[i] += isZoneFrame ? \" [\" + zoneFrame.zone.name + \"]\" : \" [\" + zoneFrame.zoneName + \"]\";\n          }\n        }\n      }\n\n      return frames.join('\\n');\n    }\n    /**\n     * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n     * adds zone information to it.\n     */\n\n\n    function ZoneAwareError() {\n      var _this = this; // We always have to return native error otherwise the browser console will not work.\n\n\n      var error = NativeError.apply(this, arguments); // Save original stack trace\n\n      var originalStack = error['originalStack'] = error.stack; // Process the stack trace and rewrite the frames.\n\n      if (ZoneAwareError[stackRewrite] && originalStack) {\n        var zoneFrame = api.currentZoneFrame();\n\n        if (zoneJsInternalStackFramesPolicy === 'lazy') {\n          // don't handle stack trace now\n          error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n        } else if (zoneJsInternalStackFramesPolicy === 'default') {\n          try {\n            error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n          } catch (e) {// ignore as some browsers don't allow overriding of stack\n          }\n        }\n      }\n\n      if (this instanceof NativeError && this.constructor != NativeError) {\n        // We got called with a `new` operator AND we are subclass of ZoneAwareError\n        // in that case we have to copy all of our properties to `this`.\n        Object.keys(error).concat('stack', 'message').forEach(function (key) {\n          var value = error[key];\n\n          if (value !== undefined) {\n            try {\n              _this[key] = value;\n            } catch (e) {// ignore the assignment in case it is a setter and it throws.\n            }\n          }\n        });\n        return this;\n      }\n\n      return error;\n    } // Copy the prototype so that instanceof operator works as expected\n\n\n    ZoneAwareError.prototype = NativeError.prototype;\n    ZoneAwareError[zoneJsInternalStackFramesSymbol] = zoneJsInternalStackFrames;\n    ZoneAwareError[stackRewrite] = false;\n    var zoneAwareStackSymbol = api.symbol('zoneAwareStack'); // try to define zoneAwareStack property when zoneJsInternal frames policy is delay\n\n    if (zoneJsInternalStackFramesPolicy === 'lazy') {\n      Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          if (!this[zoneAwareStackSymbol]) {\n            this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n          }\n\n          return this[zoneAwareStackSymbol];\n        },\n        set: function set(newStack) {\n          this.originalStack = newStack;\n          this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n        }\n      });\n    } // those properties need special handling\n\n\n    var specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace']; // those properties of NativeError should be set to ZoneAwareError\n\n    var nativeErrorProperties = Object.keys(NativeError);\n\n    if (nativeErrorProperties) {\n      nativeErrorProperties.forEach(function (prop) {\n        if (specialPropertyNames.filter(function (sp) {\n          return sp === prop;\n        }).length === 0) {\n          Object.defineProperty(ZoneAwareError, prop, {\n            get: function get() {\n              return NativeError[prop];\n            },\n            set: function set(value) {\n              NativeError[prop] = value;\n            }\n          });\n        }\n      });\n    }\n\n    if (NativeError.hasOwnProperty('stackTraceLimit')) {\n      // Extend default stack limit as we will be removing few frames.\n      NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15); // make sure that ZoneAwareError has the same property which forwards to NativeError.\n\n      Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n        get: function get() {\n          return NativeError.stackTraceLimit;\n        },\n        set: function set(value) {\n          return NativeError.stackTraceLimit = value;\n        }\n      });\n    }\n\n    if (NativeError.hasOwnProperty('captureStackTrace')) {\n      Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n        // add named function here because we need to remove this\n        // stack frame when prepareStackTrace below\n        value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n          NativeError.captureStackTrace(targetObject, constructorOpt);\n        }\n      });\n    }\n\n    var ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n    Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n      get: function get() {\n        return NativeError.prepareStackTrace;\n      },\n      set: function set(value) {\n        if (!value || typeof value !== 'function') {\n          return NativeError.prepareStackTrace = value;\n        }\n\n        return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n          // remove additional stack information from ZoneAwareError.captureStackTrace\n          if (structuredStackTrace) {\n            for (var i = 0; i < structuredStackTrace.length; i++) {\n              var st = structuredStackTrace[i]; // remove the first function which name is zoneCaptureStackTrace\n\n              if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n                structuredStackTrace.splice(i, 1);\n                break;\n              }\n            }\n          }\n\n          return value.call(this, error, structuredStackTrace);\n        };\n      }\n    });\n\n    if (zoneJsInternalStackFramesPolicy === 'disable') {\n      // don't need to run detectZone to populate zoneJs internal stack frames\n      return;\n    } // Now we need to populate the `zoneJsInternalStackFrames` as well as find the\n    // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n    // the execution through all of the above methods so that we can look at the stack trace and\n    // find the frames of interest.\n\n\n    var detectZone = Zone.current.fork({\n      name: 'detect',\n      onHandleError: function onHandleError(parentZD, current, target, error) {\n        if (error.originalStack && Error === ZoneAwareError) {\n          var frames_1 = error.originalStack.split(/\\n/);\n          var runFrame = false,\n              runGuardedFrame = false,\n              runTaskFrame = false;\n\n          while (frames_1.length) {\n            var frame = frames_1.shift(); // On safari it is possible to have stack frame with no line number.\n            // This check makes sure that we don't filter frames on name only (must have\n            // line number or exact equals to `ZoneAwareError`)\n\n            if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n              // Get rid of the path so that we don't accidentally find function name in path.\n              // In chrome the separator is `(` and `@` in FF and safari\n              // Chrome: at Zone.run (zone.js:100)\n              // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n              // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n              // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n              var fnName = frame.split('(')[0].split('@')[0];\n              var frameType = 1\n              /* transition */\n              ;\n\n              if (fnName.indexOf('ZoneAwareError') !== -1) {\n                if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                  zoneAwareFrame1 = frame;\n                  zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n                } else {\n                  zoneAwareFrame1WithoutNew = frame;\n                  zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n\n                  if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                    zoneAwareFrame3WithoutNew = frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                  }\n                }\n\n                zoneJsInternalStackFrames[zoneAwareFrame2] = 0\n                /* zoneJsInternal */\n                ;\n              }\n\n              if (fnName.indexOf('runGuarded') !== -1) {\n                runGuardedFrame = true;\n              } else if (fnName.indexOf('runTask') !== -1) {\n                runTaskFrame = true;\n              } else if (fnName.indexOf('run') !== -1) {\n                runFrame = true;\n              } else {\n                frameType = 0\n                /* zoneJsInternal */\n                ;\n              }\n\n              zoneJsInternalStackFrames[frame] = frameType; // Once we find all of the frames we can stop looking.\n\n              if (runFrame && runGuardedFrame && runTaskFrame) {\n                ZoneAwareError[stackRewrite] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        return false;\n      }\n    }); // carefully constructor a stack frame which contains all of the frames of interest which\n    // need to be detected and marked as an internal zoneJs frame.\n\n    var childDetectZone = detectZone.fork({\n      name: 'child',\n      onScheduleTask: function onScheduleTask(delegate, curr, target, task) {\n        return delegate.scheduleTask(target, task);\n      },\n      onInvokeTask: function onInvokeTask(delegate, curr, target, task, applyThis, applyArgs) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      },\n      onCancelTask: function onCancelTask(delegate, curr, target, task) {\n        return delegate.cancelTask(target, task);\n      },\n      onInvoke: function onInvoke(delegate, curr, target, callback, applyThis, applyArgs, source) {\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      }\n    }); // we need to detect all zone related frames, it will\n    // exceed default stackTraceLimit, so we set it to\n    // larger number here, and restore it after detect finish.\n    // We cast through any so we don't need to depend on nodejs typings.\n\n    var originalStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 100; // we schedule event/micro/macro task, and invoke them\n    // when onSchedule, so we can get all stack traces for\n    // all kinds of tasks with one error thrown.\n\n    childDetectZone.run(function () {\n      childDetectZone.runGuarded(function () {\n        var fakeTransitionTo = function fakeTransitionTo() {};\n\n        childDetectZone.scheduleEventTask(zoneJsInternalStackFramesSymbol, function () {\n          childDetectZone.scheduleMacroTask(zoneJsInternalStackFramesSymbol, function () {\n            childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, function () {\n              throw new Error();\n            }, undefined, function (t) {\n              t._transitionTo = fakeTransitionTo;\n              t.invoke();\n            });\n            childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, function () {\n              throw Error();\n            }, undefined, function (t) {\n              t._transitionTo = fakeTransitionTo;\n              t.invoke();\n            });\n          }, undefined, function (t) {\n            t._transitionTo = fakeTransitionTo;\n            t.invoke();\n          }, function () {});\n        }, undefined, function (t) {\n          t._transitionTo = fakeTransitionTo;\n          t.invoke();\n        }, function () {});\n      });\n    });\n    Error.stackTraceLimit = originalStackTraceLimit;\n  });\n});","map":null,"metadata":{},"sourceType":"script"}